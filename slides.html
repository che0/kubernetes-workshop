<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <title>Jak spustit aplikaci v Kubernetu </title>
    </head>
    <body>

<h1>Jak spustit aplikaci v Kubernetu</h1>

<section class="slide">
    <h2>Jak spustit aplikaci v K8s</h2>
    <p>Co Kubernetes je, jak to funguje, jak to použít</p>
    <p>Celou prezentaci a další materiály najdete na <a href="https://www.zbozi.fail/k8s/">www.zbozi.fail/k8s</a></p>
</section>

<section class="slide chapter">
    <h2>Docker</h2>
</section>

<section class="slide">
    <h2>Docker</h2>
    <p>Tvoří image a pouští kontejnery</p>
    <ul>
        <li>image je obraz systému, typicky nějaká aplikace se vším co potřebuje (knihovny, závislosti)</li>
        <li>kontejner spouštíte z image</li>
        <li>kontejner běží izolovaný od hostitelského systému, může komunikovat přes síť nebo přes volumes</li>
        <li>ekosystém rozličných imagů:<ul>
            <li><code>docker run -ti --rm ubuntu /bin/bash</code></li>
            <li><code>docker run -ti --rm debian grep ^deb /etc/apt/sources.list</code></li>
            <li><code>docker run --name databaze --rm mariadb</code></li>
            <li><code>docker run -ti --rm -v "$(pwd)/php-site:/var/www/html" -p 8000:80 php:7.2-apache</code></li>
        </ul></li>
        <li>vrstvená tvorba přes <a href="https://github.com/che0/hello-web/blob/v1/Dockerfile">Dockerfile</a></li>
        <li><code>docker run -ti --rm -p 8000:80 pn2d/hello-web:v1</code></li>
    </ul>
</section>

<section class="slide">
    <h2>Docker Hub</h2>
    <ul>
        <li><a href="hub.docker.com">hub.docker.com</a><ul>
            <li>Default repository pro Docker image</li>
            <li>Jedno privátní repository zdarma</li>
            <li>Umí samo builtit image z GitHubu</li>
        </ul></li>
        <li>Jiný repository se píše jako prefix jména image<ul>
            <li><code>docker run -ti --rm -p 8000:8080 gcr.io/google-samples/kubernetes-bootcamp:v1</code></li>
        </ul></li>
        <li>Můžete si spustit repository vlastní</li>
    </ul>
</section>

<section class="slide chapter">
    <h2>Kubernetes</h2>
</section>

<section class="slide">
    <h2>Kubernetes</h2>
    <ul>
        <li>Open source cluster, který vám spouští kontejnery</li>
        <li>Má API i klikátko, nejlíp se ovládá přes <code>kubectl</code> (dokud na něj chcete sahat)</li>
    </ul>
    <h3>Kde takový cluster vzít?</h3>
    <ul>
        <li><a href="https://kariera.seznam.cz/">kariera.seznam.cz</a></li>
        <li><a href="https://cloud.google.com/kubernetes-engine/">Google Kubernetes Engine</a> (za e-mail, telefon a číslo karty)</li>
        <li><a href="https://aws.amazon.com/eks/">Amazon EKS</a> a další(asi podobné, ale složitější na naklikání)</li>
        <li><a href="https://kubernetes.io/docs/setup/minikube/">minikube</a></li>
    </ul>
    <h3>Jak poznám že mám cluster?</h3>
    <p><code>kubectl get nodes</code> mi vypíše seznam nodů</p>
</section>

<section class="slide">
    <h2>Web</h2>
    <ul>
        <li>spustím si web<br>
            <code>kubectl run hello-web --image pn2d/hello-web:v1 --port=80</code><br>
            založí <em>deployment</em>, který se pak stará o <em>pody</em></li>
        <li>zkoumání podů<ul>
            <li><code>kubectl get pods</code></li>
            <li><code>kubectl describe pod ${pod}</code></li>
            <li><code>kubectl logs ${pod}</code></li>
            <li><code>kubectl port-forward ${pod} 8000:80</code></li>
            <li><code>kubectl exec -ti ${pod} /bin/bash</code></li>
        </ul></li>
        <li>deploymenty můžu škálovat<br>
            <code>kubectl scale --replicas=3 deploy ${deployment}</code></li>
    </ul>
    </code>
</section>

<section class="slide">
    <h2>Jak na web pustit lidi</h2>
    <p>potřebuju <em>service</em> která web dostane ven</p>
    <ul>
        <li><code>$ kubectl expose deploy hello-web \
        --port 80 --target-port 80 --type=LoadBalancer --name=pub-hello</code></li>
        <li>co se stane záleží na konkrétním clusteru, v minikube potřebujete <code>minikube service pub-hello --url</code></li>
    </ul>
    <p><code>kubectl get services</code>, <code>kubectl describe service ${service}</code></p>
</section>


<section class="slide">
    <h2>Jak se dá sahat na věci v Kubernetu</h2>
    <ol>
        <li>Imperativní příkazy: dělá věci co dostane v argumentech<ul><li><code>run</code>, <code>expose</code></li></ul></li>
        <li>Imperativní konfigurace: vytvoří/přepíše věci podle souboru<ul>
            <li><code>$ kubectl create -f web.yaml</code></li>
            <li><code>$ kubectl replace -f web.yaml</code></li>
        </ul></li>
        <li>Deklarativní konfigurace: zjistí stav objektů, porovná je s argumentem a aplikuje změny<ul>
            <li>asi nejlepší způsob, dá se spouštět na celý adresář plný YAMLů</li>
            <li><code>$ kubectl diff -f my-config</code></li>
            <li><code>$ kubectl apply -f my-config</code></li>
        </ul></li>
    </ol>
    <p>Na všechny objekty funguje <code>kubectl get</code>, <code>describe</code> a <code>delete</code>.</p>
</section>

<section class="slide">
    <h2>Jednoduchý web (znovu)</h2>
    <h3>web.yaml</h3>
    <pre>
apiVersion: apps/v1
kind: Deployment
metadata:
  name: hello-web
spec:
  replicas: 2
  selector:
    matchLabels:
      app: hello
  template:
    metadata:
      name: hello-web
      labels:
        app: hello
    spec:
      containers:
      - name: flask
        image: pn2d/hello-web:v1
        ports:
        - name: http
          containerPort: 80
    </pre>
    <ul>
        <li><code>kubectl apply -f web.yaml</code></li>
        <li><code>kubectl rollout status -f web.yaml</code></li>
    </ul>
</section>
    
<section class="slide">
    <h2>Jednoduchý web (znovu)</h2>
    <h3>loadbalancer.yaml</h3>
    <pre>
apiVersion: v1
kind: Service
metadata:
  name: hello-loadbalancer
spec:
  type: LoadBalancer
  selector:
    app: hello
  ports:
  - protocol: TCP
    port: 80
    targetPort: 80
  #loadBalancerIP: "X.X.X.X" # když chcete statickou
    </pre>
    <ul>
        <li>můžete si říct o statickou IP adresu; postup jak ji získat záleží na providerovi</li>
    </ul>
</section>

<section class="slide">
    <h2>Co když potřebuju backend?</h2>
    <p>Další skvělá komponenta: <a href="https://github.com/che0/hello-backend/blob/v1/backend.py">backend.py</a></p>
    <h3>backend.yaml</h3>
        <pre>
apiVersion: apps/v1
kind: Deployment
metadata:
  name: hello-backend
spec:
  replicas: 2
  selector:
    matchLabels:
      app: hello
      what: backend # nutno označit i front-end, jinak blbne loadbalancer
  template:
    metadata:
      name: hello-backend
      labels:
        app: hello
        what: backend
    spec:
      containers:
      - name: backend
        image: pn2d/hello-backend:v1
        ports:
        - name: http
          containerPort: 80
        </pre>
</section>

<section class="slide">
    <h2>Jak web backend najde?</h2>
    <p><em>ClusterIP</em> &ndash; jedna IP adresa v rámci clusteru</p>
    <h3>clusterip.yaml</h3>
    <pre>
kind: Service
apiVersion: v1
metadata:
  name: hello-backend
spec:
  type: ClusterIP
  selector:
    app: hello
    what: backend
  ports:
  - protocol: TCP
    port: 80
    targetPort: 80
    </pre>
    <ul>
        <li>Ke každé cluster IP DNS záznam zdarma</li>
    </ul>
</section>

<section class="slide">
    <h2>Jak web backend najde?</h2>
    <p>Adresu <a href="https://github.com/che0/hello-web/blob/v2/app/hello.py#L29">předáme v env proměnné</a></p>
    <h3>web.yaml (kousky)</h3>
    <pre>
spec:
  template:
    spec:
      containers:
      - ...
        image: pn2d/hello-web:v2
        env:
          - name: BACKEND_URL
            value: "http://hello-backend/backend"
    </pre>
</section>

<section class="slide">
    <h2>Co když mi tam něco umře?</h2>
    <h3>web.yaml (kousky)</h3>
    <pre>
spec:
  template:
    spec:
      containers:
      - ...
        livenessProbe:
          httpGet:
            path: /alive
            port: 80
          initialDelaySeconds: 5
          periodSeconds: 1
          failureThreshold: 1
        readinessProbe:
          httpGet:
            path: /ready
            port: 80
          initialDelaySeconds: 5
          periodSeconds: 1
          failureThreshold: 1
    </pre>
    <ul>
        <li><code>livenessProbe</code> = je to naživu (když není, Kubernetes kontejner restartuje)</li>
        <li><code>readinessProbe</code> = reaguje to (když není, Kubernetes na pod nesměruje provoz)</li>
        <li>kromě <code>httpGet</code> tam je i <code>exec</code> a <code>tcpSocket</code></li>
    </ul>
</section>

<section class="slide">
    <h2>Méně tupý backend</h2>
    <ul>
        <li>Měl by si věci opravdu pamatovat</li>
        <li>Použijeme databázi</li>
    </ul>
    <h3>mysql.yaml</h3>
    <pre>
kind: StatefulSet
apiVersion: apps/v1
metadata:
  name: hello-db
spec:
  serviceName: hello-db
  replicas: 1
  selector:
    matchLabels:
      app: hello
      what: db
  template:
    metadata:
      name: hello-db
      labels:
        app: hello
        what: db
    spec:
      containers:
      - name: mysql
        image: percona:5
        ports:
        - name: mysql
          containerPort: 3306
        env:
        - name: MYSQL_ROOT_PASSWORD
          value: "12345"
        - name: MYSQL_DATABASE
          value: hellodb
        - name: MYSQL_USER
          value: hello_user
        - name: MYSQL_PASSWORD
          value: "aaa"
    </pre>
</section>

<section class="slide">
    <h2>Jak na databázi směrovat provoz</h2>
    <h3>mysql.yaml (navíc)</h3>
    <pre>
---
kind: Service
apiVersion: v1
metadata:
  name: hello-db
spec:
  selector:
    app: hello
    what: db
  ports:
  - protocol: TCP
    port: 3306
    targetPort: 3306
  clusterIP: None # žádný load balancing, jenom udělá DNS
    </pre>
    <ul>
</section>

<section class="slide">
    <h2>Perzistence</h2>
    <ul>
        <li>někde v clusteru žijí <em>persistent volumes</em> (NFS, GlusterFS, HostPath, ...)</li>
        <li>pody si je nárokují přes <em>persistent volume claims</em></li>
    </ul>
    <h3>mysql.yaml (ještě pořád)</h3>
    <pre>
kind: StatefulSet
spec:
  template:
    spec:
      containers:
      - ...
        volumeMounts:
        - name: hello-db-data
          mountPath: "/var/lib/mysql"
  volumeClaimTemplates:
  - metadata:
      name: hello-db-data
    spec:
      accessModes:
      - ReadWriteOnce
      resources:
        requests:
          storage: 5Gi
    </pre>
</section>

<section class="slide">
    <h2>MySQL workaround pro Google</h2>
    <p>V Google Cloud je každý persistent volume samostatný ext4fs, který má <code>lost+found</code> a vlastníka, což MySQL nemá ráda.</p>
    <h3>mysql.yaml (ještě pořád)</h3>
    <pre>
kind: StatefulSet
spec:
  template:
    spec:
      containers:
      - ...
        args:
            - '--datadir=/var/lib/mysql'
            - '--ignore-db-dir=lost+found'
      initContainers:
      - name: chown-datadir
        image: busybox
        command: ['sh', '-c', 'chown 999:999 /mnt/mysql-data']
        volumeMounts:
        - name: hello-db-data
          mountPath: "/mnt/mysql-data"
    </pre>
</section>

<section class="slide">
    <h2>Napojení backendu</h2>
    <ul>
        <li><a href="https://github.com/che0/hello-backend/blob/v2/backend.py">backend.py</a> co sahá do MySQL</li>
        <li>nastavení zase přes env</li>
    </ul>
    <h3>backend.yaml (kus)</h3>
    <pre>
spec:
  template:
    spec:
      containers:
      - image: pn2d/hello-backend:v2
        readinessProbe:
          httpGet:
            path: /ready
            port: 80
          initialDelaySeconds: 20
          periodSeconds: 10
        env:
          - name: MYSQL_HOST
            value: hello-db
          - name: MYSQL_DATABASE
            value: hellodb
          - name: MYSQL_USER
            value: hello_user
          - name: MYSQL_PASSWORD
            value: "aaa"
    </pre>
</section>

<section class="slide">
    <h2>Konfigurace</h2>
    <p>Konfigurace se ukládá co <em>ConfigMaps</em>, což jsou vlastně key-value story</p>
    <p>ConfigMap se dá vytvářet:</p>
    <ul style="margin-left: 3em">
        <li>ze souboru (soubor bude položka)<br><code>kubectl create configmap foo --from-file=foo.config</code> nebo <code>--from-file=&lt;key&gt;=&lt;path&gt;</code></li>
        <li>z adresářů (soubory budou položky)</li>
        <li>ze souboru s položkami <code>--from-env-file</code>
        <li>z argumentů <code>--from-literal=&lt;key&gt;=&lt;value&gt;</code></li>
        <li>normálně z YAMLu</li>
    </ul>
    <h3>0config.yaml</h3>
    <pre>
apiVersion: v1
kind: ConfigMap
metadata:
  name: hello-config
data:
  backend.url: "http://hello-backend/backend"
  db.host: hello-db
  db.database: hellodb
    </pre>
    </ul>
</section>

<section class="slide">
    <h2>ConfigMap se dá používat</h2>
    <ul>
        <li>jako env proměnná: env.valueFrom.configMapKeyRef
        <li>jako sada proměnných: envFrom.configMapRef</li>
        <li>jako volume</li>
    </ul>
    <h3>web.yaml (kus)</h3>
    <pre>
spec:
  template:
    spec:
      containers:
      - ...
        env:
        - name: BACKEND_URL
          valueFrom:
            configMapKeyRef:
              name: hello-config
              key: backend.url
        envFrom:
          - configMapRef:
              name: hello-config
            prefix: FROM_FULL_CONFIGMAP_
    </pre>
</section>

<section class="slide">
    <h2>ConfigMap ve volume</h2>
    <h3>web.yaml (kus)</h3>
    <pre>
spec:
  template:
    spec:
      containers:
      - ...
        volumeMounts:
        - name: config-volume
          mountPath: /etc/config
      volumes:
      - name: config-volume
        configMap:
          name: hello-config
    </pre>
    <ul>
        <li>volume se aktualizuje hned co si pod všimne změny</li>
        <li>env proměnné se načítají jen při startu kontejneru, potom už se nemění</li>
    </ul>
</section>

<section class="slide">
    <h2>Secrets</h2>
    <p>Secrets jsou jako ConfigMapy, ale tajné</p>
    <h3>0db-root-password.yaml</h3>
    <pre>
apiVersion: v1
kind: Secret
metadata:
    name: hello-db-root-password
data:
    password: MTIzNDU=
    </pre>
    <h3>0db-passwords.yaml</h3>
    <pre>
apiVersion: v1
kind: Secret
metadata:
    name: hello-db-passwords
data:
    username: aGVsbG9fdXNlcg==
    password: YWFh
    </pre>
</section>

<section class="slide">
    <h2>Secrets &ndash; použití</h2>
    <h3>backend.yaml</h3>
    <pre>
spec:
  template:
    spec:
      containers:
      - ...
        env:
        - name: MYSQL_USER
            valueFrom:
              secretKeyRef:
                name: hello-db-passwords
                key: username
        - ...
    </pre>
    <p>Analogicky jdou doplnit do <code>envFrom</code> přes <code>secretRef</code> a jako volumes typu <code>secret</code>.</p>
</section>


<section class="slide">
    <h2>TBD</h2>
    <ul>
        <li>4. Nastaveni v configmaps, hesla do MySQL v secrets</li>
        <li>5. Normalni webova aplikace (pod s nginx + uwsgi)</li>
        <li>6. Cron joby</li>
        <li>7. Ingress</li>
        <li>8. TLS</li>
        <li>9. <a href="https://web.archive.org/web/20020408094205/http://phpbb.com/features.php">phpBB</a></li>
    </ul>
</section>

<section class="slide">
    <h2>KTHXBAI</h2>
</section>

    <script src="https://ondras.github.io/jsslides/v3/slides/slides3.js" type="text/javascript"></script>
    <script>
        Slides.modules.skin = "seznam";
        Slides.modules.progress.parent = "body";
        Slides.modules.fontsize.normal = "200%";
        Slides.modules.language = ["en", "cs"];
        Slides.modules.time.parent = "body";
        Slides.modules.time.remaining = 5 * 60 * 1000;
    </script>

</body>
</html>
